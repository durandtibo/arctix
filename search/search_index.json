{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>arctix</code> is a Python library that provides simple functions to check in a single line if two complex/nested objects are equal or not. <code>arctix</code> was initially designed to work with PyTorch <code>Tensor</code>s and NumPy <code>ndarray</code>, but it is possible to extend it to support other data structures.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Let's imagine you have the following dictionaries that contain both a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>. You want to compute a string representation of it. By default, Python tries to show the values of all the tensor/array. The <code>arctix</code> library was developed to easily compute structured string representation of nested objects. <code>arctix</code> provides a function <code>summary</code> to compute the string representation.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary({\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}))\n&lt;class 'dict'&gt; (length=2)\n  (torch): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (numpy): &lt;class 'numpy.ndarray'&gt; | shape=(2, 3) | dtype=float64\n&gt;&gt;&gt; print(\n...     summary(\n...         {\n...             \"torch\": [torch.ones(2, 3), torch.zeros(6)],\n...             \"numpy\": numpy.zeros((2, 3)),\n...             \"other\": [42, 4.2, \"abc\"],\n...         },\n...         max_depth=3,\n...     )\n... )\n&lt;class 'dict'&gt; (length=3)\n  (torch): &lt;class 'list'&gt; (length=2)\n      (0): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n      (1): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([6]) | dtype=torch.float32 | device=cpu\n  (numpy): &lt;class 'numpy.ndarray'&gt; | shape=(2, 3) | dtype=float64\n  (other): &lt;class 'list'&gt; (length=3)\n      (0): &lt;class 'int'&gt; 42\n      (1): &lt;class 'float'&gt; 4.2\n      (2): &lt;class 'str'&gt; abc\n</code></pre> <p>Please check the quickstart page to learn more on how to use <code>arctix</code>.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>arctix</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>arctix</code> to a new version will possibly break any code that was using the old version of <code>arctix</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>arctix</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install arctix\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>arctix</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'arctix[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install arctix numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>arctix</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/arctix.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate arctix\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>arctix</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p> This page gives a quick overview of the main function of <code>arctix</code>: <code>summary</code> This function can be used to compute a string representation of complex/nested objects. The motivation of the library is explained here. You should read this page if you want to learn how to use this function. This page does not explain the internal behavior of these functions.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial. It is highly recommended to know a bit of NumPy or PyTorch.</p>"},{"location":"quickstart/#summary","title":"Summary","text":"<p><code>arctix</code> provides a function <code>summary</code> to compute a string representation of complex/nested objects. It also works for simple objects like integer or string.</p>"},{"location":"quickstart/#first-example","title":"First example","text":"<p>The following example shows how to use the <code>summary</code> function. The object to summarize is a dictionary containing a PyTorch <code>Tensor</code> and a NumPy <code>ndarray</code>.</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary({\"torch\": torch.ones(2, 3), \"numpy\": numpy.zeros((2, 3))}))\n&lt;class 'dict'&gt; (length=2)\n  (torch): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (numpy): &lt;class 'numpy.ndarray'&gt; | shape=(2, 3) | dtype=float64\n&gt;&gt;&gt; print(\n...     summary(\n...         {\n...             \"torch\": [torch.ones(2, 3), torch.zeros(6)],\n...             \"numpy\": numpy.zeros((2, 3)),\n...             \"other\": [42, 4.2, \"abc\"],\n...         },\n...         max_depth=3,\n...     )\n... )\n</code></pre>"},{"location":"quickstart/#number-of-items","title":"Number of items","text":"<p>It is possible to control the number of items to show in a nested objects. For example if there is a list of 1000 tensors, it is usually not necessary to show all the items. The default string function shows all the items.</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; print(str([torch.ones(2, 3) for i in range(1000)]))\n[tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        ...  # a lot of lines are not shown\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]]), tensor([[1., 1., 1.],\n        [1., 1., 1.]])]\n</code></pre> <p>The <code>summary</code> function returns the representation of the first items in the list.</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary([torch.ones(2, 3) for i in range(1000)]))\n&lt;class 'list'&gt; (length=1,000)\n  (0): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (1): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (2): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (3): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (4): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  ...\n</code></pre> <p>By efault, the maximum number of items to show is 5, but it can be changed easily by using the context manager <code>summarizer_options</code>. The following example shows how to return the first 3 items.</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summarizer_options, summary\n&gt;&gt;&gt; with summarizer_options(max_items=3):\n...     print(summary([torch.ones(2, 3) for i in range(1000)]))\n&lt;class 'list'&gt; (length=1,000)\n  (0): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (1): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (2): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  ...\n</code></pre> <p><code>max_items</code> controls the number of items to show in lists, tuples, sets, dicts, etc. It is possible to set <code>max_items=-1</code> to return all the items:</p> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summarizer_options, summary\n&gt;&gt;&gt; with summarizer_options(max_items=-1):\n...     print(summary([torch.ones(2, 3) for i in range(1000)]))\n&lt;class 'list'&gt; (length=1,000)\n  (0): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (1): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (2): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  ...  # a lot of lines are not shown\n  (997): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (998): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n  (999): &lt;class 'torch.Tensor'&gt; | shape=torch.Size([2, 3]) | dtype=torch.float32 | device=cpu\n</code></pre>"},{"location":"quickstart/#maximum-depth","title":"Maximum depth","text":"<p>As for the maximum number of items, it is possible to control the depth where the summarization is applied in the complex/nested object. A larger <code>max_depth</code> usually leads to more detail in the string representation.</p> <ul> <li>Maximum depth 0</li> </ul> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=0))\n[[0, 1, 2], {'key1': 'abc', 'key2': 'def'}]\n</code></pre> <ul> <li>Maximum depth 1</li> </ul> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}]))\n&lt;class 'list'&gt; (length=2)\n  (0): [0, 1, 2]\n  (1): {'key1': 'abc', 'key2': 'def'}\n</code></pre> <ul> <li>Maximum depth 2</li> </ul> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=2))\n  (0): &lt;class 'list'&gt; (length=3)\n      (0): 0\n      (1): 1\n      (2): 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): abc\n      (key2): def\n</code></pre> <ul> <li>Maximum depth 3</li> </ul> <pre><code>&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from arctix import summary\n&gt;&gt;&gt; print(summary([[0, 1, 2], {\"key1\": \"abc\", \"key2\": \"def\"}], max_depth=3))\n (0): &lt;class 'list'&gt; (length=3)\n      (0): &lt;class 'int'&gt; 0\n      (1): &lt;class 'int'&gt; 1\n      (2): &lt;class 'int'&gt; 2\n  (1): &lt;class 'dict'&gt; (length=2)\n      (key1): &lt;class 'str'&gt; abc\n      (key2): &lt;class 'str'&gt; def\n</code></pre>"}]}